
// This file is part of Man, a robotic perception, locomotion, and
// team strategy application created by the Northern Bites RoboCup
// team of Bowdoin College in Brunswick, Maine, for the Aldebaran
// Nao robot.
//
// Man is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Man is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser Public License for more details.
//
// You should have received a copy of the GNU General Public License
// and the GNU Lesser Public License along with Man.  If not, see
// <http://www.gnu.org/licenses/>.

#include "Observer.h"
using std::list;

#include "motionconfig.h"
#ifdef DEBUG_MOTION
#  define DEBUG_CONTROLLER_GAINS
#endif


using namespace NBMath;

// generated by octave
const float Observer::weights[NUM_AVAIL_PREVIEW_FRAMES] =
{
  28.97201f, 45.75956f, 48.19928f, 45.79432f, 42.02619f, 38.07843f, 34.33415f,
  30.90010f, 27.78937f, 24.98477f, 22.46077f, 20.19089f, 18.15011f, 16.31549f,
  14.66628f, 13.18377f, 11.85111f, 10.65315f,  9.57629f,  8.60828f,  7.73813f,
   6.95593f,  6.25280f,  5.62074f,  5.05257f,  4.54184f,  4.08274f,  3.67004f,
   3.29906f,  2.96557f,  2.66580f,  2.39633f,  2.15410f,  1.93636f,  1.74062f,
   1.56468f,  1.40651f,  1.26434f,  1.13653f,  1.02165f,  0.91838f,  0.82554f,
   0.74209f,  0.66708f,  0.59965f,  0.53903f,  0.48455f,  0.43557f,  0.39154f,
   0.35196f,  0.31638f,  0.28440f,  0.25565f,  0.22981f,  0.20658f,  0.18570f,
   0.16693f,  0.15005f,  0.13489f,  0.12125f };

const float Observer::A_values[9] =
{  1.00000f,  0.02000f,  0.00000f,
   0.63226f,  1.00000f, -0.63226f,
  14.21503f,  2.52822f, -1.43411f };

const float Observer::b_values[3] =
{ 0.0f,
  0.0f,
  0.02f };

const float Observer::L_values[3] =
{ 0.069177f,
 -0.534042f,
 -0.326940f};

const float Observer::c_values[3] =
{ 0.0f, 0.0f, 1.0f };

const float Observer::Gi = -28.972f;

Observer::Observer()
    : WalkController(), stateVector(ufvector3(3)),
      A(ufmatrix3(3,3)), b(ufvector3(3)), c(ufrowVector3(1,3)),
      L(ufvector3(3)),trackingError(0.0f)
      {
    // instantiate the ublas matrices with their respective values
    // TODO: there might be a better way to do this.
    for (int i=0; i < 3; i++)
        stateVector(i) = 0.0f;

    for (int i=0; i < 3; i++)
        A(0, i) = A_values[i];
    for (int i=0; i < 3; i++)
        A(1, i) = A_values[3+i];
    for (int i=0; i < 3; i++)
        A(2, i) = A_values[6+i];

    for (int i=0; i < 3; i++)
        b(i) = b_values[i];

    for (int i=0; i < 3; i++)
        c(0,i) = c_values[i];

    for (int i=0; i < 3; i++)
        L(i) = L_values[i];

#ifdef DEBUG_CONTROLLER_GAINS
    FILE * gains_log;
    gains_log = fopen("/tmp/gains_log.xls","w");
    int j = 0;
    fprintf(gains_log,"time\tgain\n");
    //write the controller gains
    for(unsigned int i  = 0; i < NUM_PREVIEW_FRAMES; i++){
        fprintf(gains_log,"%d\t%f\n",j,weights[j]);
        j++;
    }
    fclose(gains_log);
#endif

}

/**
 * Tick calculates the next state vector for the robot, given the zmp_ref
 *
 */
const float Observer::tick(const list<float> *zmp_ref,
                           const float cur_zmp_ref,
                           const float sensor_zmp) {
    float preview_control = 0.0f;
    unsigned int counter = 0;

    for (list<float>::const_iterator i = zmp_ref->begin();
         counter < NUM_PREVIEW_FRAMES; ++counter, ++i) {
        preview_control += weights[counter]* (*i);
    }

    trackingError += prod(c,stateVector)(0) - cur_zmp_ref;

    const float control = -Gi * trackingError - preview_control;
    const float psensor = sensor_zmp;

    ufvector3 temp(prod(A, stateVector)
                   - L*(psensor - prod(c,stateVector)(0)) * 1.0f
                   + b*control);
    stateVector.assign(temp);

    return getPosition();
}

/**
 * Initialize the position of the robot (vel and accel assumed to be 0)
 * We also assume we are starting off without any tracking error.
 */
void Observer::initState(float x, float v, float p){
    stateVector(0) = x;
    stateVector(1) = v;
    stateVector(2) = p;
    trackingError = 0.0f;
}
